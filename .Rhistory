for( j in i:l){
qnew=sigma[h[j],]-q%*%t(q)%*%sigma[h[j],]
qnew=qnew/sqrt(sum(qnew^2))
q=cbind(q,qnew)
}
r=t(q[,1:l])%*%t(sigma[h,])
}
if(i==1&l>1){
q[,1]=sigma[h[1],]/sqrt(sum(sigma[h[1],]^2))
for(j in 2:l){
qnew=sigma[h[j],]-q[,1:(j-1)]%*%t(q[,1:(j-1)])%*%sigma[h[j],]
qnew=qnew/sqrt(sum(qnew^2))
q=cbind(q[,1:(j-1)],qnew)
}
r=t(q[,1:l])%*%t(sigma[h,])
}
if(i==1&l==1){
q[,1]=sigma[h[1],]/sqrt(sum(sigma[h[1],]^2))
r=matrix(1,nrow=1,ncol=1)
}
q=q[,1:l]
}
}
if(b[i]>(-sm)) {
c1=1
#
# now see if we need to add another hinge
#
theta=q%*%t(q)%*%y
rhat=y-theta
b2=sigma%*%rhat
# check to see if b2 negative
obs=(p+1):m
i=min(obs[b2[(p+1):m]==max(b2[(p+1):m])])
if(l<m&l>0){if(b2[i]>sm){
l=l+1
qnew=sigma[i,]-q%*%t(q)%*%sigma[i,]
qnew=qnew/sqrt(sum(qnew^2))
q=cbind(q,qnew)
h=c(h,i)
r=t(q)%*%t(sigma[h,])
c2=0
}}
if(b2[i]<sm){c2=1}
check=c1*c2
h
}
}
# find coefficient vector
b=1:l*0
b[l]=a[l]/r[l,l]
if(l>1){
for( j in (l-1):1){
b[j]=a[j]
for(i in (j+1):l){
b[j]=b[j]-r[j,i]*b[i]
}
b[j]=b[j]/r[j,j]
}
}
coef=1:m*0
coef[h]=b
coef
}
########################################
#       MAKE THE EDGE VECTORS          #
########################################
##############################################################
# B-spline quadratic basis
# returns basis functions and slopes of basis functions
# at the knots
bqspline=function(x,m){
tk=0:(m-1)/(m-1)*(max(x)-min(x))+min(x)
k=3
t=1:(m+2*k-2)*0
t[1:(k-1)]=min(x);t[(m+k):(m+2*k-2)]=max(x)
t[k:(m+k-1)]=tk
n=length(x)
sm=1e-8
h=t[4]-t[3]
bmat=matrix(1:(n*(m+k-2))*0,nrow=n)
index=x>=t[3]&x<=t[4]
bmat[index,1]=(t[4]-x[index])^2
bmat[index,2]=2*(x[index]-t[2])*(t[4]-x[index])+(t[5]-x[index])*(x[index]-t[3])
index=x>=t[4]&x<=t[5]
bmat[index,2]=(t[5]-x[index])^2
for( j in 3:(m-1) ){
index=x>=t[j]&x<=t[j+1]
bmat[index,j]=(x[index]-t[j])^2
index=x>=t[j+1]&x<=t[j+2]
bmat[index,j]=(x[index]-t[j])*(t[j+2]-x[index])+(x[index]-t[j+1])*(t[j+3]-x[index])
index=x>=t[j+2]&x<=t[j+3]
bmat[index,j]=(t[j+3]-x[index])^2
}
index=x>=t[m]&x<=t[m+1]
bmat[index,m]=(x[index]-t[m])^2
index=x>=t[m+1]&x<=t[m+2]
bmat[index,m]=(x[index]-t[m])*(t[m+2]-x[index])+2*(x[index]-t[m+1])*(t[m+3]-x[index])
index=x>=t[m+1]&x<=t[m+2]
bmat[index,m+1]=(x[index]-t[m+1])^2
#################################################
# plotting splines
xpl=0:1000/1000*(max(x)-min(x))+min(x)
bpl=matrix(1:(1001*(m+k-2))*0,nrow=1001)
index=xpl>=t[3]&xpl<=t[4]
bpl[index,1]=(t[4]-xpl[index])^2
bpl[index,2]=2*(xpl[index]-t[2])*(t[4]-xpl[index])+(t[5]-xpl[index])*(xpl[index]-t[3])
index=xpl>=t[4]&xpl<=t[5]
bpl[index,2]=(t[5]-xpl[index])^2
for( j in 3:(m-1) ){
index=xpl>=t[j]&xpl<=t[j+1]
bpl[index,j]=(xpl[index]-t[j])^2
index=xpl>=t[j+1]&xpl<=t[j+2]
bpl[index,j]=(xpl[index]-t[j])*(t[j+2]-xpl[index])+(xpl[index]-t[j+1])*(t[j+3]-xpl[index])
index=xpl>=t[j+2]&xpl<=t[j+3]
bpl[index,j]=(t[j+3]-xpl[index])^2
}
index=xpl>=t[m]&xpl<=t[m+1]
bpl[index,m]=(xpl[index]-t[m])^2
index=xpl>=t[m+1]&xpl<=t[m+2]
bpl[index,m]=(xpl[index]-t[m])*(t[m+2]-xpl[index])+2*(xpl[index]-t[m+1])*(t[m+3]-xpl[index])
index=xpl>=t[m+1]&xpl<=t[m+2]
bpl[index,m+1]=(xpl[index]-t[m+1])^2
#################################################
slopes=matrix(0,ncol=m,nrow=m+k-2)
slopes[1,1]=-2*h
slopes[m+k-2,m]=2*h
slopes[2,1]=4*h
slopes[2,2]=-2*h
if(m==4){slopes[3,2]=2*h;slopes[3,3]=-2*h}
slopes[m+k-3,m]=-4*h
slopes[m+k-3,m-1]=2*h
if(m>4){
for(j in 3:(m+k-4)){
slopes[j,j-1]=2*h
slopes[j,j]=-2*h
}
}
bmat[,1]=bmat[,1]*2
bmat[,m+1]=bmat[,m+1]*2
slopes[1,]=slopes[1,]*2
slopes[m+1,]=slopes[m+1,]*2
bpl[,1]=bpl[,1]*2
bpl[,m+1]=bpl[,m+1]*2
mb=max(bpl)
slopes=slopes/mb
bpl=bpl/mb
bmat=bmat/mb
ans=new.env()
ans$edges=bmat
ans$slopes=slopes
ans$knots=tk
ans$xpl=xpl
ans$bpl=bpl
ans
}
##############################################################
# cubic b-splines
# returns basis functions and 2nd derivative of basis functions
# at the knots
##############################################################
bcspline=function(x,m){
tk=0:(m-1)/(m-1)*(max(x)-min(x))+min(x)
k=4
t=1:(m+2*k-2)*0
t[1:(k-1)]=min(x);t[(m+k):(m+2*k-2)]=max(x)
t[k:(m+k-1)]=tk
n=length(x)
sm=1e-8
m0=matrix(1:(n*(m+k+1))*0,nrow=n)
for( j in 4:(m+k-1) ){
if(t[j]<t[j+1]-sm){
index=x<=t[j+1]&x>t[j]
m0[index,j]=1
}
}
m0[1,k]=1
m1=matrix(1:(n*(m+k))*0,nrow=n)
for( j in 3:(m+k-1) ){
index=x>t[j]&x<=t[j+2]
if(t[j+1]>t[j]+sm){
p1=(x[index]-t[j])/(t[j+1]-t[j])*m0[index,j]
}else{p1=0}
if(t[j+2]>t[j+1]+sm){
p2= (t[j+2]-x[index])/(t[j+2]-t[j+1])*m0[index,j+1]
}else{p2=0}
m1[index,j]=p1+p2
}
imin=x==min(x)
m1[imin,k-1]=1
m2=matrix(1:(n*(m+k-1))*0,nrow=n)
for( j in 2:(m+k-1) ){
index=x>t[j]&x<=t[j+3]
if(t[j+2]>t[j]+sm){
p1=(x[index]-t[j])/(t[j+2]-t[j])*m1[index,j]
}else{p1=0}
if(t[j+3]>t[j+1]+sm){
p2=(t[j+3]-x[index])/(t[j+3]-t[j+1])*m1[index,j+1]
}else{p2=0}
m2[index,j]=p1+p2
}
m2[imin,k-2]=1
m3=matrix(1:(n*(m+k-2))*0,nrow=n)
for( j in 1:(m+k-2) ){
index=x>=t[j]&x<=t[j+4]
if(t[j+3]>t[j]+sm){
p1=(x[index]-t[j])/(t[j+3]-t[j])*m2[index,j]
}else{p1=0}
if(t[j+4]>t[j+1]+sm){
p2=(t[j+4]-x[index])/(t[j+4]-t[j+1])*m2[index,j+1]
}else{p2=0}
m3[index,j]=p1+p2
}
#  plotting splines
np=1000
xpl=0:(np-1)/(np-1)*(max(x)-min(x))+min(x)
m0pl=matrix(1:(np*(m+k+1))*0,nrow=np)
for( j in 4:(m+k-1) ){
if(t[j]<t[j+1]-sm){
index=xpl<=t[j+1]&xpl>t[j]
m0pl[index,j]=1
}
}
m0pl[1,k]=1
m1pl=matrix(1:(np*(m+k))*0,nrow=np)
for( j in 3:(m+k-1) ){
index=xpl>t[j]&xpl<=t[j+2]
if(t[j+1]>t[j]+sm){
p1=(xpl[index]-t[j])/(t[j+1]-t[j])*m0pl[index,j]
}else{p1=0}
if(t[j+2]>t[j+1]+sm){
p2= (t[j+2]-xpl[index])/(t[j+2]-t[j+1])*m0pl[index,j+1]
}else{p2=0}
m1pl[index,j]=p1+p2
}
m1pl[1,k-1]=1
m2pl=matrix(1:(np*(m+k-1))*0,nrow=np)
for( j in 2:(m+k-1) ){
index=xpl>t[j]&xpl<=t[j+3]
if(t[j+2]>t[j]+sm){
p1=(xpl[index]-t[j])/(t[j+2]-t[j])*m1pl[index,j]
}else{p1=0}
if(t[j+3]>t[j+1]+sm){
p2=(t[j+3]-xpl[index])/(t[j+3]-t[j+1])*m1pl[index,j+1]
}else{p2=0}
m2pl[index,j]=p1+p2
}
m2pl[1,k-2]=1
m3pl=matrix(1:(np*(m+k-2))*0,nrow=np)
for( j in 1:(m+k-2) ){
index=xpl>=t[j]&xpl<=t[j+4]
if(t[j+3]>t[j]+sm){
p1=(xpl[index]-t[j])/(t[j+3]-t[j])*m2pl[index,j]
}else{p1=0}
if(t[j+4]>t[j+1]+sm){
p2=(t[j+4]-xpl[index])/(t[j+4]-t[j+1])*m2pl[index,j+1]
}else{p2=0}
m3pl[index,j]=p1+p2
}
# matrix of second derivatives
secder=matrix(0,ncol=m,nrow=m+k-2)
secder[1,1]=6
secder[2,1]=-9
secder[2,2]=3/2
secder[3,1]=3
secder[3,2]=-5/2
secder[3,3]=1
if(m>4){
for(j in 4:(m-1)){
secder[j,j-2]=1;secder[j,j-1]=-2;secder[j,j]=1
}
}
secder[m,m-2]=1
secder[m,m-1]=-5/2
secder[m,m]=3
secder[m+1,m-1]=3/2
secder[m+1,m]=-9
secder[m+2,m]=6
ans=new.env()
ans$bpl=m3pl
ans$xpl=xpl
ans$edges=m3
ans$d2=secder
ans$knots=tk
ans
}
x=runif(50)
y=exp(2*x)+rnorm(50)
ans=penspl(5,x,y,10,3,2.5)
print(ans$xpl)
lines(ans$xpl,ans$cpl)
lines(ans$xpl,ans$ucpl,col=2)
y_clean = exp(2*ans$xpl)
divide_ans <- function(ans,runs){
#           cfit = constrained fit
#           ucfit = unconstrained fit
#           cgcv = constrained GCV
#           ucgcv = unconstrained GCV
#           edfc = effective degrees of freedom for constrained fit
#           edfu = effective degrees of freedom for unconstrained fit
#           knots
#           xpl = grid of points for plotting smooth fits
#           cpl = constrained fit values at xpl
#           ucpl = unconstrained fit values at xpl
ans$cfit = ans$cfit / runs
ans$ucfit = ans$ucfit / runs
ans$cgcv = ans$cgcv / runs
ans$ucgv = ans$ucgv / runs
ans$cpl = ans$cpl / runs
ans$ucpl = ans$ucpl / runs
return(ans)
}
add_ans <- function(ans_1,ans_2){
#           cfit = constrained fit
#           ucfit = unconstrained fit
#           cgcv = constrained GCV
#           ucgcv = unconstrained GCV
#           edfc = effective degrees of freedom for constrained fit
#           edfu = effective degrees of freedom for unconstrained fit
#           knots
#           xpl = grid of points for plotting smooth fits
#           cpl = constrained fit values at xpl
#           ucpl = unconstrained fit values at xpl
ans_1$cfit = ans_1$cfit+ans_2$cfit
ans_1$ucfit = ans_1$ucfit + ans_2$ucfit
ans_1$cgcv = ans_1$cgcv + ans_1$cgcv
ans_1$ucgv = ans_1$ucgv + ans_2$ucgv
ans_1$cpl = ans_1$cpl + ans_2$cpl
ans_1$ucpl = ans_1$ucpl + ans_2$ucpl
return(ans_1)
}
find_x_new <- function(xpl, x){
i = 1
for (candidate in xpl){
if (x[i]-candidate < 0){
x[i] = candidate
i = i + 1
#print("change")
}
}
return(x)
}
find_indizes <- function(xpl,x){
i = 1
j = 1
for (candidate in xpl){
if (x[i]-candidate < 0){
x[i] = j
i = i + 1
#print("change")
}
j = j + 1
}
return(x)
}
find_y <- function(xpl,y,x){
i = 1
j = 1
for (candidate in xpl){
if (x[i]-candidate < 0){
x[i] = y[j]
i = i + 1
#print("change")
}
j = j + 1
}
return(x)
}
# how many times do we run the simulation
runs = 10
# how many datapoint in each run
n_candidates = c(1000)
run_simulation <-function(runs,n_candidates, objective_function, objective_function_name){
p = 3 # degree of splines used
unconstrained_errors <- character(runs)
constrained_errors <- character(runs)
#ans_list <- list(length(n_candidates))
j = 0
#unconstrained_errors_data <- character(runs)
#constrained_errors_data <- character(runs)
# Create the data frames.
sim_results <- data.frame(
runs="",
datapoints="",
knots="",
objective_function="",
#constrained_errors_data="",
#unconstrained_errors_data="",
constrained_errors = "",
unconstrained_errors = "",
#time
stringsAsFactors = FALSE
)
for (n in n_candidates){
print("enters for")
print("j equals:")
print(j)
j = j + 1
for (i in 1:runs) {
print("enter runs")
x = runif(n)
y = objective_function(x) + rnorm(n)
#print("we get to penspl")
ans = penspl(5,x,y,round(3 * (n^(1/(2*p + 3))),digits = 0),3,2.5)
if (i == 1){
ans_mean = ans
}
else{
ans_mean = add_ans(ans_mean,ans)
}
#x = find_x_new(ans$xpl,x)
y_clean = objective_function(ans$xpl)
#y_clean_data = objective_function(x)
#y_constrained_data = find_y(ans$xpl,ans$cpl,x)
#y_unconstrained_data = find_y(ans$xpl,ans$ucpl,x)
#constrained_errors_data[i] = mean(abs(y_constrained_data - y_clean_data))
#unconstrained_errors_data[i] = mean(abs(y_unconstrained_data - y_clean_data))
constrained_errors[i] = mean(abs(objective_function(ans$xpl)-ans$cpl))
unconstrained_errors[i] = mean(abs(objective_function(ans$xpl)-ans$ucpl))
}
unconstrained_errors = mean(as.numeric(unconstrained_errors))
constrained_errors = mean(as.numeric(constrained_errors))
#unconstrained_errors_data = as.numeric(unconstrained_errors_data)
#constrained_errors_data = as.numeric(constrained_errors_data)
#unc_errors_data = mean(unconstrained_errors_data)
#con_errors_data =mean(constrained_errors_data)
if (j == 1){
print("ans_means defined")
ans_means = list(ans_mean)
}
else{
ans_means = c(ans_means, ans_mean)
}
sim_results = rbind(sim_results, data.frame(
runs = runs,
datapoints = n,
knots = round(3*(n^(1/(2*p + 3)))),
objective_function = c(objective_function_name),
#constrained_errors_data = c(con_errors_data),
#unconstrained_errors_data = c(unc_errors_data),
constrained_errors = c(constrained_errors),
unconstrained_errors = c(unconstrained_errors),
#time
stringsAsFactors = FALSE)
)
}
print("lol")
return(list("stats" = sim_results, "data" = ans_means))
}
plot_results <- function(runs, n, objective_function_name,  objective_function, data){
true_y = objective_function(data$xpl)
plot(data$xpl,true_y,type= "l",col = "black", ylab = "y", xlab = "x")
lines(data$xpl,data$cpl, col = "blue")
lines(data$xpl,data$ucpl,col="red")
#lines(data$xpl,true_y,col = "black")
legend("topleft", legend=c("constrained","unconstrained","objective"), col = c("blue","red","black"),lty=1:2,cex=0.8,title = paste(objective_function_name,", n =",as.character(n)))
}
if (TRUE == TRUE){
function_1 <- function(x){
return(x^3)
}
function_1_name = "x-> x^3"
function_2 <- function(x){
return(-0.005*x +3)
}
function_2_name = "x -> -0.005*x +3"
function_3 <- function(x){
return(2+x^3-0.2*x)
}
function_3_name = "x -> x^3 - 0.2x + 2"
function_4 <- function(x){
return(-x^3)
}
function_4_name = "x -> -x^3"
objective_functions = list(
list(function(x) function_1(x),name = function_1_name,data = NULL),
list(f = function(x) function_2(x),name = function_2_name, data = NULL),
list(f = function(x) function_3(x),name = function_3_name, data = NULL),
list(f = function(x) function_4(x),name = function_4_name, data = NULL)
)
objective_functions_2 = list(
function(x) function_1(x),
function(x) function_2(x),
function(x) function_3(x)
)
objective_functions_2[[1]](2)
objective_functions[[1]][[1]](2)
function_0 <- function(x){
return(x + 1)
}
} # Here we define objective functions
if (TRUE == TRUE){
sim_results = run_simulation(runs,n_candidates,function_0,"x -> x + 1")$stats
print("worked")
i = 1
for (bundle in objective_functions){
print("i equals:")
print(i)
sim_results_new = run_simulation(runs,n_candidates,bundle[[1]],bundle[[2]])
sim_results = rbind(sim_results,sim_results_new$stats)
objective_functions[[i]][[3]] = sim_results_new$data
i = i + 1
}
#print(sim_results$data)[[1]]$xpl
#run_simulation(runs,n,function_1, "x -> x^3")
print(sim_results)
print("objective_functions equals:")
print(objective_functions[[1]])
objective_functions[[1]]$data[[1]]$xpl
objective_functions[[1]][[3]][[1]]$xpl
print("done")
plot_results(runs,1000,objective_functions[[1]]$name,objective_functions[[1]]$f,objective_functions[[1]]$data[[1]])
